# -*- coding: utf-8 -*-
"""RPSGame.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SA_KxnDheTmJRiNtv9uB8RvhdEaNOHGL
"""

import random

class RPSGame:
    def __init__(self):  # Fixed constructor method
        # Store history of moves and results
        self.history = []

    def update_history(self, user_move, opponent_move, result):
        # Append the round's moves and result to the history
        self.history.append((user_move, opponent_move, result))

    def show_last_n_history(self, n=6):
        if not self.history:
            print("No history available.")
        else:
            print(f"{'Round':<6}{'User Move':<12}{'Opponent Move':<15}{'Outcome':<10}")
            for i, (user_move, opponent_move, result) in enumerate(self.history[-n:], len(self.history) - min(n, len(self.history)) + 1):
                print(f"{i:<6}{user_move:<12}{opponent_move:<15}{result:<10}")

    def predict_user_move(self):
        """Predict the user's next move based on recent history and patterns."""
        if not self.history:  # Fixed indentation here
            return random.choice(['R', 'P', 'S'])  # Random if no history

        # Focus on the last few rounds to detect recent trends
        recent_history = self.history[-3:]  # Look at the last 3 moves
        move_counts = {'R': 0, 'P': 0, 'S': 0}

        # Count occurrences in recent moves
        for user_move, _, _ in recent_history:
            move_counts[user_move] += 1

        # If one move has been used more in recent rounds, predict it
        most_common_recent_move = max(move_counts, key=move_counts.get)

        # Additionally, check for sequential patterns (e.g., rotating through moves)
        if len(recent_history) >= 2:
            if recent_history[-2][0] == 'R' and recent_history[-1][0] == 'P':
                return 'S'  # Predict Scissors if the user seems to be rotating in a Rock → Paper → Scissors pattern
            elif recent_history[-2][0] == 'P' and recent_history[-1][0] == 'S':
                return 'R'  # Predict Rock if user follows a Paper → Scissors → Rock pattern
            elif recent_history[-2][0] == 'S' and recent_history[-1][0] == 'R':
                return 'P'  # Predict Paper if user follows a Scissors → Rock → Paper pattern

        return most_common_recent_move

    def decide_move(self):
        """Choose the best move to counter the predicted user's move."""
        predicted_move = self.predict_user_move()
        print(f"AI predicts user will choose: {predicted_move}")

        if predicted_move == 'R':
            return 'P'  # Counter Rock with Paper
        elif predicted_move == 'P':
            return 'S'  # Counter Paper with Scissors
        else:
            return 'R'  # Counter Scissors with Rock

    def get_result(self, user_move, ai_move):
        """Determine the result of the round: Win, Lose, or Draw."""
        if user_move == ai_move:
            return 'D'  # Draw
        elif (user_move == 'R' and ai_move == 'S') or \
             (user_move == 'P' and ai_move == 'R') or \
             (user_move == 'S' and ai_move == 'P'):
            return 'W'  # Win for the user
        else:
            return 'L'  # Loss for the user

def play_game():
    game = RPSGame()
    rounds = int(input("How many rounds do you want to play? "))

    for round_num in range(1, rounds + 1):
        print(f"\nRound {round_num}:")

        # Get user input
        user_move = input("Enter your move (R for Rock, P for Paper, S for Scissors): ").upper()
        while user_move not in ['R', 'P', 'S']:
            print("Invalid move. Please enter R, P, or S.")
            user_move = input("Enter your move (R for Rock, P for Paper, S for Scissors): ").upper()

        # AI decides its move based on the predicted user move
        ai_move = game.decide_move()
        print(f"AI move: {ai_move}")

        # Determine the result
        result = game.get_result(user_move, ai_move)
        if result == 'W':
            print("You win!")
        elif result == 'L':
            print("AI wins!")
        else:
            print("It's a draw!")

        # Update history
        game.update_history(user_move, ai_move, result)

    # Show the last 6 rounds of history
    print("\nGame history:")
    game.show_last_n_history(n=6)

# Start the game
play_game()